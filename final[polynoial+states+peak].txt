def calculate_agreement_disagreement(seq1, seq2):
    """Calculate agreement and disagreement between two sequences"""
    agreement = sum(1 for x, y in zip(seq1, seq2) if x == y)
    disagreement = len(seq1) - agreement
    return agreement, disagreement

def auto_correlation(seq):
    """Calculate full auto-correlation for a sequence"""
    length = len(seq)
    original_seq = seq
    results = []
    peak = 0  # Initialize peak value

    for shift in range(1, length):  # Start from shift 1
        shifted_seq = seq[shift:] + seq[:shift]  # Circular shift
        agreement, disagreement = calculate_agreement_disagreement(original_seq, shifted_seq)
        result = agreement - disagreement
        results.append((shift, shifted_seq, agreement, disagreement, result))
        
        # Track peak (max absolute correlation)
        peak = max(peak, abs(result))

    return results, peak

def cross_correlation(seq1, seq2):
    """Calculate full cross-correlation between two sequences"""
    length = len(seq1)
    results = []
    peak = 0  # Initialize peak value

    for shift in range(1, length):  # Start from shift 1
        shifted_seq2 = seq2[shift:] + seq2[:shift]  # Circular shift
        agreement, disagreement = calculate_agreement_disagreement(seq1, shifted_seq2)
        result = agreement - disagreement
        results.append((shift, shifted_seq2, agreement, disagreement, result))

        # Track peak (max absolute correlation)
        peak = max(peak, abs(result))

    return results, peak


# ---------------- Step 1: Ask polynomial degree ----------------
degree = int(input("Enter the degree of the polynomial: "))

# ---------------- Step 2: Generate generic polynomial ----------------
generic_coeffs = [1] * (degree + 1)

def polynomial_to_string(coeffs):
    deg = len(coeffs) - 1
    terms = []
    for i, c in enumerate(coeffs):
        power = deg - i
        if c == 0:
            continue
        if power == 0:
            terms.append(str(c))
        elif power == 1:
            terms.append("x")
        else:
            terms.append(f"x^{power}")
    return " + ".join(terms)

print("Generic polynomial:", polynomial_to_string(generic_coeffs))

# ---------------- Step 3: Ask user for actual coefficients ----------------
user_input = input(f"Enter {degree+1} coefficients (highest degree first, no spaces): ")
actual_coeffs = list(map(int, user_input))
print("Actual polynomial:", polynomial_to_string(actual_coeffs))

# ---------------- Step 4: Calculate d' ----------------
d_prime = 2**degree + 1
print(f"Calculated d' (number of states): {d_prime}")

# ---------------- Step 5: Ask for initial states of all possible states ----------------
initial_states = []
print(f"\nPlease enter the initial states ({degree} digits) for all {d_prime} states:")

for i in range(d_prime):
    state_input = input(f"State {i+1} ({degree} digits): ")
    while len(state_input) != degree or not state_input.isdigit():
        print("Invalid input! Please enter exactly", degree, "digits.")
        state_input = input(f"State {i+1} ({degree} digits): ")
    initial_states.append([int(x) for x in state_input])

# ---------------- Step 6: Form LHS-RHS equation ----------------
lhs_degree = degree
rhs_coeffs = actual_coeffs[1:]

# ---------------- Step 7: Convert RHS to mod-4 ----------------
mod = 4
rhs_mod_coeffs = [(-c) % mod for c in rhs_coeffs]

def mod_polynomial_string(coeffs, degree):
    terms = []
    power = degree - 1
    for c in coeffs:
        if c != 0:
            if power == 0:
                terms.append(f"{c}")
            elif power == 1:
                terms.append(f"{c}x")
            else:
                terms.append(f"{c}x^{power}")
        power -= 1
    return " + ".join(terms)

print(f"Feedback equation (mod-{mod}): x^{degree} = {mod_polynomial_string(rhs_mod_coeffs, degree)}\n")

# ---------------- Step 8: Ask for number of iterations ----------------
iterations = int(input("Enter the number of iterations for each state: "))

# ---------------- Step 9: Iterative LFSR with first-time reverse ----------------
final_outputs = []

for state in initial_states:
    state_rev = state[::-1]  # Reverse only once for first iteration
 +cr   feedback_list = []

    for step in range(iterations):
        feedback = sum(rhs_mod_coeffs[i] * state_rev[i] for i in range(len(rhs_mod_coeffs))) % mod
        feedback_list.append(feedback)
        state_rev = [feedback] + state_rev[:-1]  # Slide window

    feedback_str = ''.join(str(f) for f in feedback_list)
    # Combine original state + feedback sequence
    final_output = ''.join(str(d) for d in state) + feedback_str
    final_outputs.append(final_output)

# ---------------- Step 10: Correlation Calculations ----------------
print("\nCorrelation results:")

# ---------------- Step 11: Auto-correlation for all states ----------------
for i, final_output in enumerate(final_outputs):
    print(f"\nAuto-correlation for State {i+1}: {final_output}")
    auto_corr_results, auto_peak = auto_correlation(final_output)
    for shift, shifted_seq, agreement, disagreement, corr_result in auto_corr_results:
        print(f"Shift {shift}: {shifted_seq} -> Agreement: {agreement}, Disagreement: {disagreement}, Result: {corr_result}")
    
    print(f"Peak auto-correlation for this state: {auto_peak}")

# ---------------- Step 12: Cross-correlation between all pairs ----------------
for i, final_output in enumerate(final_outputs):
    for j, other_output in enumerate(final_outputs):
        if i != j:
            print(f"\nCross-correlation between State {i+1}: {final_output} and State {j+1}: {other_output}")
            cross_corr_results, cross_peak = cross_correlation(final_output, other_output)
            for shift, shifted_seq, agreement, disagreement, corr_result in cross_corr_results:
                print(f"Shift {shift}: {shifted_seq} -> Agreement: {agreement}, Disagreement: {disagreement}, Result: {corr_result}")
            
            print(f"Peak cross-correlation for this pair: {cross_peak}")
